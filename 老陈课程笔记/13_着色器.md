 

## ShaderMaterial

> gl_Position//顶点位置(内置变量)
> gl_FragColor//片元着色器的最终颜色值(内置变量)
>
> vec4 必须使用浮点数
>
> ;不能省略

![image-20240408070530671](img/image-20240408070530671.png)

## 三个矩阵转换

通过矩阵转换 物体才能正确的在屏幕上显示出来

```c
gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 ) ;
```

### 模型矩阵

modelMatrix

用于将局部坐标（对象自身的坐标系）变换为世界坐标。它包括对象的位置、旋转和缩放信息

### 视图矩阵

viewMatrix

将3D坐标从模型空间转换到相机空间。它包括相机的位置和朝向，以便将场景正确投影到相机视角,相机的移动缩放、旋转会改变这个矩阵

由相机位置、相机朝向、相机视角决定

### 投影矩阵

projectionMatrix

将物体从三维空间映射到二维屏幕上。

由投影类型（正交投影或透视投影）和投影平面决定

## 使用glsl格式书写着色器

shader插件

显示不同的代码颜色

![image-20231019161702393](img/image-20231019161702393.png)

glsl文件书写

![image-20240408071349460](img/image-20240408071349460.png)

导入glsl文件

![image-20240408071433836](img/image-20240408071433836.png)

使用

![image-20240408071444138](img/image-20240408071444138.png)

## 着色器语言用法

### uniform

所有顶点数据中相同的数据

三个模型矩阵

### attribute

顶点中不同的数据

顶点位置 uv

### varying

将顶点着色器的数据传递到片元着色器

## RawShaderMaterial

原始着色器材质

### 顶点着色器

![image-20240408075059000](img/image-20240408075059000.png)



在shaderMaterial中省略的内容

```glsl
precision lowp float;
attribute vec3 color;
attribute vec3 position;//顶点位置
attribute vec2 uv;//uv

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
```

### 浮点数精度

一般放在最前面

![image-20240408075141245](img/image-20240408075141245.png)

### 顶点着色器向片元传递数据

varing的数据可以进行传递

顶点着色器

![image-20240408074725053](img/image-20240408074725053.png)

![image-20240408074804417](img/image-20240408074804417.png)

片元着色器

![image-20240408074903789](img/image-20240408074903789.png)

### uv

uv的原点在左下角

uv中存的是0-1的值 是对应的物体的每一个顶点位置

### ShaderMaterial

可以添加的属性

![image-20240408113107134](img/image-20240408113107134.png)

平面倾斜

![image-20240408113623339](img/image-20240408113623339.png)

### sin函数

![image-20240408114125566](img/image-20240408114125566.png)

## 旗帜波纹运动案例

### 波纹

顶点着色器设置形成波纹

![image-20240408115350560](img/image-20240408115350560.png)

波纹随着高度产生明暗变化 越高越亮

顶点着色器传递z高度

![image-20240408120034702](img/image-20240408120034702.png)

将r值和高度关联

![image-20240408120325172](img/image-20240408120325172.png)

运算顺序

*比+优先计算

num++和num+=1一样

++位置的区别

在运算中num++是先使用num值 之后使用才+1

++num在运算中使用直接使用num+1的值

### 传递时间

定义着色器变量

![image-20240408140908882](img/image-20240408140908882.png)

变量赋值

![image-20240408140754723](img/image-20240408140754723.png)



顶点着色器使用时间

![image-20240408141323449](img/image-20240408141323449.png)

传递纹理

![image-20240408141648933](img/image-20240408141648933.png)

使用纹理并随着高度变化

![image-20240408142106020](img/image-20240408142106020.png)

### 渐变

左到右，黑到白渐变

![image-20231020114029431](img/image-20231020114029431.png)

下到上，黑到白渐变

![image-20231020114304734](img/image-20231020114304734.png)

渐变反向

![image-20231020114417020](img/image-20231020114417020.png)

取模mod，做多次渐变

mod用第一个参数除第二个参数 结果为余数

0-1 除以1.0 余数是0-1

1-2 除以1.0 余数是0-1

...

0-0.1区间内放大10倍取余就是0-1,也就是一次黑到白的渐变

![image-20231020115039458](img/image-20231020115039458.png)

斑马条纹

step函数 用来取整

0-1得0-1 0.5以下是0黑色 0.5以上白色

![image-20231020120406377](img/image-20231020120406377.png)

横竖窗户条纹

<img src="img/image-20240408144416959.png" alt="image-20240408144416959" style="zoom:25%;" />

![image-20231020120706968](img/image-20231020120706968.png)

白色点 条纹相乘

<img src="img/image-20231020120939950.png" alt="image-20231020120939950" style="zoom: 50%;" />

![image-20231020120925125](img/image-20231020120925125.png)

条纹相减 1-0的是白色，其他都是黑色



<img src="img/image-20231020121052619.png" alt="image-20231020121052619" style="zoom:25%;" />

![image-20231020121301702](img/image-20231020121301702.png)

方块条纹 

<img src="img/image-20231020121457820.png" alt="image-20231020121457820" style="zoom:50%;" />

![image-20231020121519515](img/image-20231020121519515.png)

灰黑灰

abs 取绝对值

![image-20231020122812922](img/image-20231020122812922.png)

![image-20231020122610127](img/image-20231020122610127.png)

十字架

min取两个值中小的

   

![image-20231020150146217](img/image-20231020150146217.png)

![image-20231020151703929](img/image-20231020151703929.png)

取最大值

<img src="img/image-20231020152003247.png" alt="image-20231020152003247" style="zoom: 50%;" />

```glsl
// 18 取最大值
float strength =max(abs(vUv.x - 0.5), abs(vUv.y - 0.5)) ;
gl_FragColor =vec4(strength,strength,strength,1);
```

没有黑色边框

<img src="img/image-20231020152323912.png" alt="image-20231020152323912" style="zoom:50%;" />

```glsl
// 19 step
float strength =step(0.2,max(abs(vUv.x - 0.5), abs(vUv.y - 0.5)))   ;
gl_FragColor =vec4(strength,strength,strength,1);
```

<img src="img/image-20231020162244612.png" alt="image-20231020162244612" style="zoom:50%;" />

![image-20231020162226394](img/image-20231020162226394.png)

floor向下取整 0.9=>0 1.9=>1

0-10

0-1 0

1-2 1

0-9的整数

最后得到0 0.1 ...0.9 

<img src="img/image-20231020162734242.png" alt="image-20231020162734242" style="zoom:50%;" />

![image-20231020163043942](img/image-20231020163043942.png)

取整相乘

<img src="img/image-20231020163344601.png" alt="image-20231020163344601" style="zoom:50%;" />

![image-20231020163818770](img/image-20231020163818770.png)

向上取整ceil

0-10 得到1到10的整数

```glsl
float strength = ceil(vUv.x*10.0)/10.0*ceil(vUv.y*10.0)/10.0;
    gl_FragColor =vec4(strength,strength,strength,1);
```

https://thebookofshaders.com/10/?lan=ch

随机函数 生成0-1的随机数

<img src="img/image-20231020171313469.png" alt="image-20231020171313469" style="zoom:50%;" />

float是指返回值是浮点数

![image-20231020165750502](img/image-20231020165750502.png)

```glsl
// 随机函数
float random (vec2 st) {
    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);
}
```

![image-20240408153210137](img/image-20240408153210137.png)

随机格子



<img src="img/image-20231020171228227.png" alt="image-20231020171228227" style="zoom:50%;" />

![image-20240408153549642](img/image-20240408153549642.png)

length

围绕0,0以半径长度渐变

<img src="img/image-20231020171936682.png" alt="image-20231020171936682" style="zoom:50%;" />

![image-20231020171921430](img/image-20231020171921430.png)

distance

计算两个点的距离

<img src="img/image-20231020172215058.png" alt="image-20231020172215058" style="zoom:50%;" />

![image-20231020172203531](img/image-20231020172203531.png)

<img src="img/image-20231020174048995.png" alt="image-20231020174048995" style="zoom:50%;" />

0.15/0.15得1 -1得0 黑色

0.15/0.14大于1 -1 圈内灰色

0.15/0.07得2 -1 0.07内都是白色

0.15/0.16 小于1 -1 得黑色

![image-20231020174039202](img/image-20231020174039202.png)



压扁星星

uv.y0-1 *5.0 得0-5 变化会更剧烈 所以y轴会被压扁 

<img src="img/image-20231020175059096.png" alt="image-20231020175059096" style="zoom:50%;" />

```glsl
float strength =0.15 / distance(vec2(vUv.x,(vUv.y-0.5)*5.0),vec2(0.5,0.5)) - 1.0;
    gl_FragColor =vec4(strength,strength,strength,strength);

```

十字星星

![image-20231020175803557](img/image-20231020175803557.png)

![image-20231020175515383](img/image-20231020175515383.png)

旋转函数



```glsl
// 旋转函数
vec2 rotate(vec2 uv, float rotation, vec2 mid)
{
    return vec2(
      cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,
      cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y
    );
}
```

将旋转的结果替换uv即可

![image-20231020180610666](img/image-20231020180610666.png)

圆形

![image-20231020181108869](img/image-20231020181108869.png)

距离如果大于0.5 就是1 白色的

+0.25 距离大于0.25就是白色

```glsl
 float strength = step(0.5,distance(vUv,vec2(0.5))+0.25) ;
    gl_FragColor =vec4(strength,strength,strength,1);
```

圆形

取反就是 0-1 变成1-0 就是用1减去

![image-20231020181207540](img/image-20231020181207540.png)

![image-20231020181222045](img/image-20231020181222045.png)



![image-20231020181501518](img/image-20231020181501518.png)

距离大于0.15 得1

距离小于0.15 得0

距离大于0.25 得0

距离小于0.25 得1

0.15-0.25为白色

![image-20231020181449989](img/image-20231020181449989.png)

渐变环

<img src="img/image-20231023113510075.png" alt="image-20231023113510075" style="zoom:50%;" />

0-0.5 -0.25到0.25 取绝对值0.25-0-0.25 白黑白

![image-20231023113458388](img/image-20231023113458388.png)

<img src="img/image-20231023114045842.png" alt="image-20231023114045842" style="zoom:50%;" />

0.25-0.1取1白

0.1到0.1 黑

大于0.1 白

```glsl
float strength = step(0.1,abs(distance(vUv,vec2(0.5))-0.25));
    gl_FragColor =vec4(strength,strength,strength,1);
```

波浪环

<img src="img/image-20231023115056703.png" alt="image-20231023115056703" style="zoom:50%;" />

```glsl
 vec2 waveUv = vec2(
        vUv.x,
        vUv.y+sin(vUv.x*30.0)*0.1
    );


    float strength = 1.0 -  step(0.01,abs(distance(waveUv,vec2(0.5))-0.25))   ;
    gl_FragColor =vec4(strength,strength,strength,1);
```

<img src="img/image-20231023115438034.png" alt="image-20231023115438034" style="zoom:50%;" />

```glsl
vec2 waveUv = vec2(
        vUv.x+sin(vUv.y*30.0)*0.1,
        vUv.y+sin(vUv.x*30.0)*0.1
    );
    float strength = 1.0 - step(0.01,abs(distance(waveUv,vec2(0.5))-0.25))   ;
    gl_FragColor =vec4(strength,strength,strength,1);
```

atan返回的是弧度值

![image-20240408165753249](img/image-20240408165753249.png)

<img src="img/image-20231023160247729.png" alt="image-20231023160247729" style="zoom:50%;" />

0-π/2 到1就是白

![image-20231023160229897](img/image-20231023160229897.png)

<img src="img/image-20231023165831112.png" alt="image-20231023165831112" style="zoom:50%;" />

![image-20231023165738348](img/image-20231023165738348.png)

<img src="img/image-20231023170339706.png" alt="image-20231023170339706" style="zoom:50%;" />

透明度 大于0.5为0黑色

![image-20231023170309811](img/image-20231023170309811.png)





雷达旋转

```glsl
vec2 rotateUv = rotate(vUv,-uTime*5.0,vec2(0.5));
float alpha =  1.0 - step(0.5,distance(vUv,vec2(0.5)));
float angle = atan(rotateUv.x-0.5,rotateUv.y-0.5);
float strength = (angle+3.14)/6.28;
gl_FragColor =vec4(strength,strength,strength,alpha);
```

<img src="img/image-20231023173306713.png" alt="image-20231023173306713" style="zoom:50%;" />

<img src="img/image-20231023173320053.png" alt="image-20231023173320053" style="zoom:150%;" />

定义常量

```glsl
#define PI 3.1415926535897932384626433832795
```

<img src="img/image-20231023174539714.png" alt="image-20231023174539714" style="zoom:50%;" />

![image-20231023174632229](img/image-20231023174632229.png)

噪音函数

<img src="img/image-20231023180410723.png" alt="image-20231023180410723" style="zoom:50%;" />

```glsl
float noise (in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}
```

*100是为了更密集

![image-20231023180446096](img/image-20231023180446096.png)

mix混合 0前一个颜色，1后一个颜色 最后是第一个颜色的占比

```glsl
vec3 mixColor =  mix(greenColor,purpleColor,1.0);
```

### 孔明灯案例

通过法向让物体光滑

![image-20240408200736325](img/image-20240408200736325.png)

着色器材质设置

![image-20231024113302532](img/image-20231024113302532.png)

顶点着色器

gPosition为初始的坐标

gPosition是模型变换之前的坐标 也就是blender导入时的坐标

用gPosition/模型高度 得到顶点距离底部的高度 越高越接近红色

vPosition是模型变化后的坐标

![image-20231024113625640](img/image-20231024113625640.png)

片元着色器

gl_FrontFacing 判断是正面还是反面 true是正面

vPosition.y表示模型在y轴上的高度 越高值越大

mixColor.xyz-常量 会对每一个变量减去常量

-20表示物体在20高度 80是所有灯笼的高度

![image-20231024113938854](img/image-20231024113938854.png)

gsap可以加等于自身

![image-20240409111758422](img/image-20240409111758422.png)

设置控制器限制到某个值

控制器就会以某角度看

```
controls.maxPolarAngle = (Math.PI / 3) * 2;
controls.minPolarAngle = (Math.PI / 3) * 2;
```

